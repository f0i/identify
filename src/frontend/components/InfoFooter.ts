import template from "./InfoFooter.html";
import { showElement } from "../identify/dom";

declare global {
  interface Window {
    showInfo: (sectionId: string) => void;
  }
}

export function createInfoFooter(): HTMLElement {
  const templateElement = document.createElement("template");
  templateElement.innerHTML = template;
  const infoFooter = templateElement.content.firstChild as HTMLElement;

  // Store the content sections
  const helpContent = `
    <h2>Help</h2>
    <h3>Logging In</h3>
    <p>To log in, click the Sign-In button. Select your account and you'll be redirected to the service you want to use. Each application will get a separate identity.</p>
    <h3>Why Are Separate Identities Used?</h3>
    <p>Each application uses a unique identity to ensure your activities in one app are independent from others. This keeps your data and actions isolated between applications, preventing malicious applications from steeling your assets from another app.</p>
    <h3>Common Issues</h3>
    <ul>
      <li><strong>I can’t log in:</strong> Ensure that you’ve selected the correct Google account and that you have internet access.</li>
      <li><strong>Login expired:</strong> If you're logged out automatically, it may be due to an expired session. Please log in again.</li>
      <li><strong>Permissions issue:</strong> Make sure you’ve granted the necessary permissions when prompted during login.</li>
    </ul>
    <h3>Browser Compatibility</h3>
    <p>This application should work with all modern browsers. Please ensure your browser is up to date for the best performance.</p>
    <h3>Need Further Assistance?</h3>
    <p>If you're experiencing issues or have questions, please contact us at <a href="mailto:support@login.f0i.de">support@login.f0i.de</a>.</p>
  `;

  const securityContent = `
    <h2>Security</h2>
    <h3>Data Protection</h3>
    <p>Your login credentials are securely handled using Google Sign-In. The application does not store any of your passwords or sensitive information. All interactions with the application are conducted over secure, encrypted connections.</p>
    <h3>Separate Identities</h3>
    <p>Each application you access through this platform uses a separate identity, ensuring that no data is shared between apps. This helps keep your information compartmentalized and private.</p>
    <h3>Minimal Data Collection</h3>
    <p>The application only requests the basic information necessary to authenticate your login through Google.
    The canister stores the following data:
      <ul>
        <li>Google account ID</li>
        <li>Email address</li>
        <li>URL of the application requestin authentication (protocol and host name)</li>
        <li>Time of each login</li>
      </ul>
    </p>
    <h3>No Private keys in canister</h3>
    <p>
      The identity delegation is created by leveraging canister signatures.
      These are threshold signatures, so there is no single point of failure to extract the private keys.
      The signatures can only be generated by the specific backend canister.
      Deploying on another canister would result in different identities.
      Canister signatures are also used by Internet-Identity and NFID.
    </p>
    <h3>Automatic Login Management</h3>
    <p>The platform automatically manages your login sessions. You do not need to manually handle your credentials or identities, reducing the risk of mistakes or unauthorized access.</p>
    <h3>No off-chain components</h3>
    <p>
      Token verification is done completely inside the backend canister.
      Google obviously uses theire own infrastructure for token generation and signing, but there are no additional off-chain componentes required for verification and signing in.
    </p>
    <h3>Protection against token reuse</h3>
    <p>
      The messages send to the Internet Computer could be observed by the gateway provider and node provider.
      Therefore the sign in tokens generated by google are linked to the current session key.
      This ensures that an attacker can't reuse the token to sign in with a stolen auth token.
    </p>
    <h2>Risks</h2>
    <h3>Canister Control</h3>
    <p>
      This system is currently controlled by a single developer. However, you can run your own instance or deploy it alongside your dApp. This eliminates the need to trust an additional controller for your specific deployment. Instructions for self-setup are available in the <a href="https://github.com/f0i/identify">f0i/identify GitHub repository</a>. While SNS/DAO could offer decentralization, it introduces new complexities and potential attack vectors.
    </p>
    <h3>Account Takeover</h3>
    <p>
      If your external identity provider account (e.g., Google, Auth0, GitHub, X) is compromised, an attacker could log in as you. If the provider locks your account, you may lose access here too.
    </p>
    <h3>DNS Attacks</h3>
    <p>
      Control over the authentication provider's domain could allow an attacker to inject malicious code or perform Man-in-the-Middle (MITM) attacks during authentication. A service worker offers limited protection.
    </p>
    <h3>HTTP Outcall Vulnerabilities (PKCE Providers like GitHub, X)</h3>
    <p>
      For providers using PKCE (e.g., GitHub, X), the backend makes HTTP outcalls that are not replicated across all nodes. A malicious node could potentially manipulate the authentication response or impersonate the application if a client secret is involved (like with GitHub). You must trust the node providers in the subnet.
    </p>
    <h3>No Security Audit</h3>
    <p>
      The code has not undergone a formal security audit. While critical paths have been reviewed and discussions held with DFINITY team members to address theoretical attacks, a third-party audit would provide more assurance.
    </p>
    <h3>Browser and Network Security</h3>
    <p>
      This system assumes your browser is secure, free from malicious extensions, and that your connection to the external identity provider is secure. It also assumes the external identity providers themselves are secure.
    </p>
    <h3>Data Visibility</h3>
    <p>
      HTTP gateways can read, block, or delay requests. Node providers can read canister state and data during HTTP outcalls. While they cannot modify execution, sensitive information could be exposed.
    </p>
  `;

  const aboutContent = `
    <h2>About</h2>
    <p>This application allows users to log in using Google and interact with services on the Internet Computer. Each application receives with a separate identity for authentication, ensuring that user sessions are independent across different apps.</p>
    <h3>Version</h3>
    <p>Current version: <span id="version">${process.env.BUILD_TIME!}</span></p>
    <h3>Contact</h3>
    <p>This application was developed by <a href="https://cubeworksgmbh.de">CubeWorks GmbH</a>, specialists in embedded software and web/mobile development. CubeWorks provides customized software solutions and expert consulting.</p>
    <p>For inquiries, please contact us at <a href="mailto:info@login.f0i.de">info@login.f0i.de</a> or reach out to CubeWorks directly at <a href="mailto:info@cubeworksgmbh.de">info@cubeworksgmbh.de</a>.</p>
  `;

  const contents: { [key: string]: string } = {
    help: helpContent,
    security: securityContent,
    about: aboutContent,
  };

  window.showInfo = (sectionId: string) => {
    const modalBody = document.getElementById("modal-body");
    if (modalBody && contents[sectionId]) {
      modalBody.innerHTML = contents[sectionId];
      showElement("modal-overlay", true);
      // Update URL hash
      history.replaceState(null, "", `#${sectionId}`);
    }
  };

  const links = infoFooter.querySelectorAll(".footer a");
  links.forEach((link) => {
    link.addEventListener("click", (event) => {
      event.preventDefault();
      const sectionId = (event.target as HTMLAnchorElement).hash.substring(1);
      window.showInfo(sectionId);
    });
  });

  // Close modal when clicking close button or overlay
  const modalClose = infoFooter.querySelector("#modal-close");
  const modalOverlay = infoFooter.querySelector("#modal-overlay");
  if (modalClose) {
    modalClose.addEventListener("click", () => {
      showElement("modal-overlay", false);
      history.replaceState(null, "", document.location.pathname + document.location.search);
    });
  }
  if (modalOverlay) {
    modalOverlay.addEventListener("click", (event) => {
      if (event.target === modalOverlay) {
        showElement("modal-overlay", false);
        history.replaceState(null, "", document.location.pathname + document.location.search);
      }
    });
  }

  return infoFooter;
}
